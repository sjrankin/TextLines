//
//  UIColor.swift
//  UIColor
//
//  Created by Stuart Rankin on 7/18/21. Adapted from Flatland View.
//

import Foundation
import UIKit
import CoreGraphics

// MARK: - UIColor extensions.

extension UIColor
{
    /// Create an UIColor using a hex string generated by `Hex` using the format `#rrggbbaa` or
    /// `#rrggbb`.
    /// - Notes: The format of `HexString` is `#rrggbbaa` where `rr`, `gg`, `bb`, and `aa`
    ///         are all hexidecimal values. Badly formatted strings will result in nil
    ///         being returned.
    /// - Parameter HexString: The string to use as the source value for the color.
    /// - Parameter RGBA: Determines the expected order of the channels. If this parameter is `true`, channels
    ///                   are expected in RGBA order. If this parameter is false, channels are expected in
    ///                   ARGB order.
    /// - Returns: Nil on error, UIColor on success.
    convenience init?(HexString: String, RGBA: Bool = true)
    {
        if RGBA
        {
            if let (Red, Green, Blue, Alpha) = Utility.ColorChannelsFromRGBA(HexString)
            {
                self.init(red: Red, green: Green, blue: Blue, alpha: Alpha)
            }
            else
            {
                return nil
            }
        }
        else
        {
            if let (Red, Green, Blue, Alpha) = Utility.ColorChannelsFromARGB(HexString)
            {
                self.init(red: Red, green: Green, blue: Blue, alpha: Alpha)
            }
            else
            {
                return nil
            }
        }
    }
    
    /// Create an UIColor using a value interpreted as a hex color value. See also `UIColor(RGB:)`.
    /// - Parameter RGBA: Value to convert to a color. Value is assumed to be in the format of `rrggbbaa`.
    /// - Returns: `UIColor` based on the passed value.
    convenience init(RGBA: UInt)
    {
        var Red: UInt = 0
        var Green: UInt = 0
        var Blue: UInt = 0
        var Alpha: UInt = 0xff
        
        Red = RGBA & 0xff000000
        Red = Red >> 24
        Green = RGBA & 0x00ff0000
        Green = Green >> 16
        Blue = RGBA & 0x0000ff00
        Blue = Blue >> 8
        Alpha = RGBA & 0x000000ff
        Alpha = Alpha >> 0
        
        let FinalRed: CGFloat = CGFloat(Red) / 255.0
        let FinalGreen: CGFloat = CGFloat(Green) / 255.0
        let FinalBlue: CGFloat = CGFloat(Blue) / 255.0
        let FinalAlpha: CGFloat = CGFloat(Alpha) / 255.0
        self.init(red: FinalRed, green: FinalGreen, blue: FinalBlue, alpha: FinalAlpha)
    }
    
    /// Create an UIColor using a value interpreted as a hex color value. The value to convert is assumed
    /// to be an RGB value. See also `UIColor(RGBA:)`.
    /// - Warning: If the value of `RGB` is greater than `0xffffff` a fatal error will be thrown.
    /// - Parameter RGB: Value to convert to a color in the format `rrggbb`. Alpha is assigned 1.0.
    /// - Returns: `UIColor` base on the passed value.
    convenience init(RGB: Int)
    {
        if RGB > 0xffffff
        {
            Debug.FatalError("RGB value of \(RGB) is too big to convert to a color.")
        }
        
        var Red = RGB & 0xff0000
        Red = Red >> 16
        var Green = RGB & 0x00ff00
        Green = Green >> 8
        let Blue = RGB & 0x0000ff >> 0
        
        let FinalRed: CGFloat = CGFloat(Red) / 255.0
        let FinalGreen: CGFloat = CGFloat(Green) / 255.0
        let FinalBlue: CGFloat = CGFloat(Blue) / 255.0
        self.init(red: FinalRed, green: FinalGreen, blue: FinalBlue, alpha: 1.0)
    }
    
    /// Force convert the passed `CGColor` to an RGB colorspace.
    /// - Notes: See [Converting CGColor from Grayspace.](https://medium.com/@avinapaner/converting-cgcolor-from-gray-spaces-to-rgb-spaces-coregraphics-ed49faecfc7f)
    /// - Parameter From: The color to convert.
    /// - Returns: `UIColor` equivalent of `From` in the RGB colorspace.
    static func ForceRGB(From: CGColor) -> UIColor
    {
        let RGBColorSpace = CGColorSpaceCreateDeviceRGB()
        if let Result = From.converted(to: RGBColorSpace, intent: .defaultIntent, options: nil)
        {
            return UIColor(cgColor: Result)
        }
        else
        {
            return UIColor.red
        }
    }
    
    /// Force convert the passed `UIColor` to an RGB colorspace.
    /// - Parameter From: The color to convert.
    /// - Returns: Same color as passed but in an RGB colorspace.
    static func ForceRGB(_ From: UIColor) -> UIColor
    {
        let CColor = From.cgColor
        return ForceRGB(From: CColor)
    }
    
    public static func ColorDistance(_ Color1: UIColor, _ Color2: UIColor) -> CGFloat
    {
        var Red1: CGFloat = 0.0
        var Green1: CGFloat = 0.0
        var Blue1: CGFloat = 0.0
        var Alpha1: CGFloat = 0.0
        var Red2: CGFloat = 0.0
        var Green2: CGFloat = 0.0
        var Blue2: CGFloat = 0.0
        var Alpha2: CGFloat = 0.0
        Color1.getRed(&Red1, green: &Green1, blue: &Blue1, alpha: &Alpha1)
        Color2.getRed(&Red2, green: &Green2, blue: &Blue2, alpha: &Alpha2)
        let RD = pow(Red1 - Red2, 2)
        let GD = pow(Green1 - Green2, 2)
        let BD = pow(Blue1 - Blue2, 2)
        let Distance = sqrt(RD + GD + BD)
        return Distance
    }
    
    /// Interpolate between two colors. The first color is the instance color.
    /// - Notes: See [Interpolating gradient colors](https://stackoverflow.com/questions/20323180/interpolating-gradient-colors-as-with-nsgradient-on-ios)
    /// - Parameter InitialColor: The target color.
    /// - Parameter Distance: Distance between the first (instance) color and the target (`InitialColor`) color.
    ///                       This value is assumed to be a normal value.
    /// - Returns: Color in between the instance color and the passed color.
    func Interpolate2(_ InitialColor: UIColor, _ Distance: CGFloat) -> UIColor
    {
        /// Returns a value between `Start` and `End` for the specified distance.
        /// - Parameter Start: Starting value.
        /// - Parameter End: Ending value.
        /// - Parameter Distance: Distance in between `Start` and `End`. This value is assumed to be a normal.
        func interpolate(_ Start: CGFloat, _ End: CGFloat, _ Distance: CGFloat) -> CGFloat
        {
            return Start + (End - Start) * Distance
        }
        
        let FromRGBColor: UIColor = UIColor.ForceRGB(self)
        let ToRGBColor: UIColor = UIColor.ForceRGB(InitialColor)
        #if true
        let Red: CGFloat = interpolate(FromRGBColor.r, ToRGBColor.r, Distance)
        let Green: CGFloat = interpolate(FromRGBColor.g, ToRGBColor.g, Distance)
        let Blue: CGFloat = interpolate(FromRGBColor.b, ToRGBColor.b, Distance)
        let Alpha: CGFloat = interpolate(FromRGBColor.a, ToRGBColor.a, Distance)
        #else
        //let FromRGBColor: UIColor = self.usingColorSpace(.genericRGB)!
        //let ToRGBColor: UIColor = InitialColor.usingColorSpace(.genericRGB)!
        let Red: CGFloat = interpolate(FromRGBColor.redComponent, ToRGBColor.redComponent, Distance)
        let Green: CGFloat = interpolate(FromRGBColor.greenComponent, ToRGBColor.greenComponent, Distance)
        let Blue: CGFloat = interpolate(FromRGBColor.blueComponent, ToRGBColor.blueComponent, Distance)
        let Alpha: CGFloat = interpolate(FromRGBColor.alphaComponent, ToRGBColor.alphaComponent, Distance)
        #endif
        return UIColor.init(red: Red, green: Green, blue: Blue, alpha: Alpha)
    }
    
    /// Returns an interpolated color between the two passed colors.
    /// - Parameter Color1: First color.
    /// - Parameter Color2: Second color.
    /// - Parameter Distance: How far the interpolated color is between `Color1` and `Color2`. This function
    ///                       expects this value to be normalized. If it isn't, the value is clamped to 0.0
    ///                       to 1.0.
    /// - Returns: Interpolated color between the two passed color.
    public static func Interpolate(_ Color1: UIColor, _ Color2: UIColor, Distance: Double) -> UIColor
    {
        var Dist = CGFloat(Distance)
        Dist = Dist < 0.0 ? 0.0 : Dist
        Dist = Dist > 1.0 ? 1.0 : Dist
        let (H1, S1, L1) = Color1.HSL
        let (H2, S2, L2) = Color2.HSL
        let HDelta = abs(H1 - H2)
        let HPercent = HDelta * Dist
        let SDelta = abs(S1 - S2)
        let SPercent = SDelta * Dist
        let LDelta = abs(L1 - L2)
        let LPercent = LDelta * Dist
        let FinalH = min(H1, H2) + HPercent
        let FinalS = min(S1, S2) + SPercent
        let FinalL = min(L1, L2) + LPercent
        return UIColor(hue: FinalH, saturation: FinalS, brightness: FinalL, alpha: 1.0)
    }
    
    /// Returns an interpolated color between the instance color and the passed color.
    /// - Parameter Other: The other color to use to interpolate a new color.
    /// - Parameter Distance: How far the interpolated color is between the instance color and `Other`.
    /// - Returns: Interpolated color between the instance color and the other color.
    public func Interpolate(_ Other: UIColor, Distance: Double) -> UIColor
    {
        return UIColor.Interpolate(self, Other, Distance: Distance)
    }
    
    /// Returns the color as a color guaranteed to be in RGB colorspace.
    var InRGB: UIColor
    {
        get
        {
            let CColor = CIColor(color: self)
            return UIColor(red: CColor.red, green: CColor.green, blue: CColor.blue, alpha: CColor.alpha)
        }
    }
    
    /// Convert the instance color to CMYK channels.
    /// - Notes: No color profiles are used - just the naive algorithm.
    /// - Returns: Tuple with cyan, magenta, yellow, and black channels, each mutliplied by 100.0.
    func ToCMYK() -> (Cyan: CGFloat, Magenta: CGFloat, Yellow: CGFloat, Black: CGFloat)
    {
        let RGB = self.InRGB
        var Red: CGFloat = 0.0
        var Green: CGFloat = 0.0
        var Blue: CGFloat = 0.0
        var Alpha: CGFloat = 0.0
        RGB.getRed(&Red, green: &Green, blue: &Blue, alpha: &Alpha)
        let K = 1.0 - max(Red, Green, Blue)
        if K == 1.0
        {
            return (0.0, 0.0, 0.0, 100.0)
        }
        let C = (1.0 - Red - K) / (1.0 - K)
        let M = (1.0 - Green - K) / (1.0 - K)
        let Y = (1.0 - Blue - K) / (1.0 - K)
        return (C * 100.0, M * 100.0, Y * 100.0, K * 100.0)
    }
    
    /// Convert the passed CMYK channels to an equivalent set of RGB channels.
    /// - Notes: Color profiles are not used in the conversion process.
    /// - Parameter Cyan: The cyan channel value.
    /// - Parameter Magenta: The magenta channel value.
    /// - Parameter Yellow: The yellow channel value.
    /// - Parameter Black: The black channel value.
    /// - Returns: Tuple with red, green, and blue channel values.
    public static func CMYKtoRGB(Cyan: CGFloat, Magenta: CGFloat, Yellow: CGFloat, Black: CGFloat) -> (Red: CGFloat, Green: CGFloat, Blue: CGFloat)
    {
        let R = (1.0 - Cyan) * (1.0 - Black)
        let G = (1.0 - Magenta) * (1.0 - Black)
        let B = (1.0 - Yellow) * (1.0 - Black)
        return (R, G, B)
    }
    
    /// Returns the value of the color as a hex string. The string has the prefix
    /// `#` and is in RGBA order.
    /// - Notes: This property converts all colors to sRGB prior to conversion to a hex string.
    var Hex: String
    {
        get
        {
            #if true
            let Working = UIColor.ForceRGB(self)
            #else
            let Working = self.usingColorSpace(.sRGB)
            #endif
            var Red: CGFloat = 0.0
            var Green: CGFloat = 0.0
            var Blue: CGFloat = 0.0
            var Alpha: CGFloat = 0.0
            Working.getRed(&Red, green: &Green, blue: &Blue, alpha: &Alpha)
            let IRed = Int(Red * 255.0)
            let SRed = String(format: "%02x", IRed)
            let IGreen = Int(Green * 255.0)
            let SGreen = String(format: "%02x", IGreen)
            let IBlue = Int(Blue * 255.0)
            let SBlue = String(format: "%02x", IBlue)
            let IAlpha = Int(Alpha * 255.0)
            let SAlpha = String(format: "%02x", IAlpha)
            let Final = "#" + SRed + SGreen + SBlue + SAlpha
            return Final
        }
    }
    
    /// Return a color based on the instance color but with the hue inverted (eg, `1.0 - self.Hue`).
    /// - Returns: Color based on the instance color but with an inverted hue.
    var InvertedHue: UIColor
    {
        let (H, S, B) = self.HSB
        let NewH = 1.0 - H
        return UIColor(hue: NewH, saturation: S, brightness: B, alpha: self.Alpha)
    }
    
    /// Returns the alpha value of the instance color.
    var Alpha: CGFloat
    {
        var Red: CGFloat = 0.0
        var Green: CGFloat = 0.0
        var Blue: CGFloat = 0.0
        var Alpha: CGFloat = 0.0
        self.getRed(&Red, green: &Green, blue: &Blue, alpha: &Alpha)
        return Alpha
    }
    
    /// Return a darkened version of the instance color.
    /// - Parameter By: The percent to darken the color. Multiplies this value by the brightness value of
    ///                 the instance color. If the caller ignores the context and passes a value greater than
    ///                 `1.0`, this function will lighten the color. Negative values are converted to positive
    ///                 values.
    /// - Returns: New color with the brightness channel modified as described in the `By` section.
    func Darker(By: CGFloat = 0.5) -> UIColor
    {
        let FinalBy = abs(By)
        let (H, S, B) = self.HSB
        let A = self.Alpha
        return UIColor(hue: H, saturation: S, brightness: B * FinalBy, alpha: A)
    }
    
    /// Returns the YUV equivalent of the instance color, in Y, U, V order.
    /// - See
    ///   - [YUV](https://en.wikipedia.org/wiki/YUV)
    ///   - [FourCC YUV to RGB Conversion](http://www.fourcc.org/fccyvrgb.php)
    var YUV: (Y: CGFloat, U: CGFloat, V: CGFloat)
    {
        get
        {
            let Wr: CGFloat = 0.299
            let Wg: CGFloat = 0.587
            let Wb: CGFloat = 0.114
            let Umax: CGFloat = 0.436
            let Vmax: CGFloat = 0.615
            var Red: CGFloat = 0.0
            var Green: CGFloat = 0.0
            var Blue: CGFloat = 0.0
            var Alpha: CGFloat = 0.0
            self.getRed(&Red, green: &Green, blue: &Blue, alpha: &Alpha)
            let Y = (Wr * Red) + (Wg * Green) + (Wb * Blue)
            let U = Umax * ((Blue - Y) / (1.0 - Wb))
            let V = Vmax * ((Red - Y) / (1.0 - Wr))
            return (Y, U, V)
        }
    }
    
    /// Returns the CMYK equivalent of the instance color, in C, M, Y, K order.
    var CMYK: (C: CGFloat, Y: CGFloat, M: CGFloat, K: CGFloat)
    {
        get
        {
            var Red: CGFloat = 0.0
            var Green: CGFloat = 0.0
            var Blue: CGFloat = 0.0
            var Alpha: CGFloat = 0.0
            self.getRed(&Red, green: &Green, blue: &Blue, alpha: &Alpha)
            let K: CGFloat = 1.0 - max(Red, max(Green, Blue))
            var C: CGFloat = 0.0
            var M: CGFloat = 0.0
            var Y: CGFloat = 0.0
            if K == 1.0
            {
                C = 1.0
            }
            else
            {
                C = abs((1.0 - Red - K) / (1.0 - K))
            }
            if K == 1.0
            {
                M = 1.0
            }
            else
            {
                M = abs((1.0 - Green - K) / (1.0 - K))
            }
            if K == 1.0
            {
                Y = 1.0
            }
            else
            {
                Y = abs((1.0 - Blue - K) / (1.0 - K))
            }
            return (C, M, Y, K)
        }
    }
    
    /// Returns the hue, saturation, and brightness channels. Convenience property for calling
    /// getHue on the color.
    /// - Notes: If the instance color cannot be converted to the SRGB colorspace, all returned components
    ///         are set to `0.0`.
    var HSB: (H: CGFloat, S: CGFloat, B: CGFloat)
    {
        var Hue: CGFloat = 0.0
        var Saturation: CGFloat = 0.0
        var Brightness: CGFloat = 0.0
        var Alpha: CGFloat = 0.0
        #if true
        let Scratch = UIColor.ForceRGB(self)
        Scratch.getHue(&Hue, saturation: &Saturation, brightness: &Brightness, alpha: &Alpha)
        return (H: Hue, S: Saturation, B: Brightness)
        #else
        if let ScratchColor = self.usingColorSpace(.sRGB)
        {
            ScratchColor.getHue(&Hue, saturation: &Saturation, brightness: &Brightness, alpha: &Alpha)
            return (H: Hue, S: Saturation, B: Brightness)
        }
        else
        {
            return (H: 0.0, S: 0.0, B: 0.0)
        }
        #endif
    }
    
    /// Returns the CIE LAB equivalent of the instance color, in L, A, B order.
    /// - Notes: See (Color math and programming code examples)[http://www.easyrgb.com/en/math.php]
    var LAB: (L: CGFloat, A: CGFloat, B: CGFloat)
    {
        get
        {
            let (X, Y, Z) = self.XYZ
            var Xr = X / 111.144                //X referent is X10 incandescent/tungsten
            var Yr = Y / 100.0                  //Y referent is X10 incandescent/tungsten
            var Zr = Z / 35.2                   //Z referent is X10 incandescent/tungsten
            if Xr > 0.008856
            {
                Xr = pow(Xr, (1.0 / 3.0))
            }
            else
            {
                Xr = (7.787 * Xr) + (16.0 / 116.0)
            }
            if Yr > 0.008856
            {
                Yr = pow(Yr, (1.0 / 3.0))
            }
            else
            {
                Yr = (7.787 * Yr) + (16.0 / 116.0)
            }
            if Zr > 0.008856
            {
                Zr = pow(Zr, (1.0 / 3.0))
            }
            else
            {
                Zr = (7.787 * Zr) + (16.0 / 116.0)
            }
            let L = (Xr * 116.0) - 16.0
            let A = 500.0 * (Xr - Yr)
            let B = 200.0 * (Yr - Zr)
            return (L, A, B)
        }
    }
    
    /// Returns the XYZ equivalent of the instance color, in X, Y, Z order.
    /// - Notes: See (Color math and programming code examples)[http://www.easyrgb.com/en/math.php]
    var XYZ: (X: CGFloat, Y: CGFloat, Z: CGFloat)
    {
        get
        {
            var Red: CGFloat = 0.0
            var Green: CGFloat = 0.0
            var Blue: CGFloat = 0.0
            var Alpha: CGFloat = 0.0
            self.getRed(&Red, green: &Green, blue: &Blue, alpha: &Alpha)
            if Red > 0.04045
            {
                Red = pow(((Red + 0.055) / 1.055), 2.4)
            }
            else
            {
                Red = Red / 12.92
            }
            if Green > 0.04045
            {
                Green = pow(((Green + 0.055) / 1.055), 2.4)
            }
            else
            {
                Green = Green / 12.92
            }
            if Blue > 0.04045
            {
                Blue = pow(((Blue + 0.055) / 1.055), 2.4)
            }
            else
            {
                Blue = Blue / 12.92
            }
            Red = Red * 100.0
            Green = Green * 100.0
            Blue = Blue * 100.0
            let X = (Red * 0.4124) + (Green * 0.3576) * (Blue * 0.1805)
            let Y = (Red * 0.2126) + (Green * 0.7152) * (Blue * 0.0722)
            let Z = (Red * 0.0193) + (Green * 0.1192) * (Blue * 0.9505)
            return (X, Y, Z)
        }
    }
    
    /// Returns the HSL equivalent of the instance color, in H, S, L order.
    /// - Notes: See (Color math and programming code examples)[http://www.easyrgb.com/en/math.php]
    var HSL: (H: CGFloat, S: CGFloat, L: CGFloat)
    {
        get
        {
            var Red: CGFloat = 0.0
            var Green: CGFloat = 0.0
            var Blue: CGFloat = 0.0
            var Alpha: CGFloat = 0.0
            self.getRed(&Red, green: &Green, blue: &Blue, alpha: &Alpha)
            let Min = min(Red, Green, Blue)
            let Max = max(Red, Green, Blue)
            let Delta = Max - Min
            let L: CGFloat = (Max + Min) / 2.0
            var H: CGFloat = 0.0
            var S: CGFloat = 0.0
            if Delta != 0.0
            {
                if L < 0.5
                {
                    S = Max / (Max + Min)
                }
                else
                {
                    S = Max / (2.0 - Max - Min)
                }
                let DeltaR = (((Max - Red) / 6.0) + (Max / 2.0)) / Max
                let DeltaG = (((Max - Green) / 6.0) + (Max / 2.0)) / Max
                let DeltaB = (((Max - Blue) / 6.0) + (Max / 2.0)) / Max
                if Red == Max
                {
                    H = DeltaB - DeltaG
                }
                else
                    if Green == Max
                {
                        H = (1.0 / 3.0) + (DeltaR - DeltaB)
                    }
                else
                    if Blue == Max
                {
                        H = (2.0 / 3.0) + (DeltaG - DeltaR)
                    }
                if H < 0.0
                {
                    H = H + 1.0
                }
                if H > 1.0
                {
                    H = H - 1.0
                }
            }
            return (H, S, L)
        }
    }
    
    /// Returns the greatest channel magnitude.
    var GreatestMagnitude: CGFloat
    {
        get
        {
            var Red: CGFloat = 0.0
            var Green: CGFloat = 0.0
            var Blue: CGFloat = 0.0
            var Alpha: CGFloat = 0.0
            self.getRed(&Red, green: &Green, blue: &Blue, alpha: &Alpha)
            return max(Red, Green, Blue)
        }
    }
    
    /// Returns the least channel magnitude.
    var LeastMagnitude: CGFloat
    {
        get
        {
            var Red: CGFloat = 0.0
            var Green: CGFloat = 0.0
            var Blue: CGFloat = 0.0
            var Alpha: CGFloat = 0.0
            self.getRed(&Red, green: &Green, blue: &Blue, alpha: &Alpha)
            return min(Red, Green, Blue)
        }
    }
    
    /// Returns a brightened version of the instance color.
    /// - Paraemter By: The percent value to multiply the instance color's brightness component by.
    ///                 If this is not a normal value (0.0 - 1.0), the original color is returned
    ///                 unchanged.
    /// - Returns: Brightened color.
    func Brighten(By Percent: CGFloat) -> UIColor
    {
        if Percent >= 1.0
        {
            return self
        }
        if Percent < 0.0
        {
            return self
        }
        var Hue: CGFloat = 0.0
        var Saturation: CGFloat = 0.0
        var Brightness: CGFloat = 0.0
        var Alpha: CGFloat = 0.0
        self.getHue(&Hue, saturation: &Saturation, brightness: &Brightness, alpha: &Alpha)
        let Multiplier = 1.0 + Percent
        Brightness = Brightness * Multiplier
        return UIColor(hue: Hue, saturation: Saturation, brightness: Brightness, alpha: Alpha)
    }
    
    /// Returns a darkened version of the instance color.
    /// - Paraemter By: The percent value to multiply the instance color's brightness component by.
    ///                 If this is not a normal value (0.0 - 1.0), the original color is returned
    ///                 unchanged.
    /// - Returns: Darkened color.
    func Darken(By Percent: CGFloat) -> UIColor
    {
        if Percent >= 1.0
        {
            return self
        }
        if Percent < 0.0
        {
            return self
        }
        var Hue: CGFloat = 0.0
        var Saturation: CGFloat = 0.0
        var Brightness: CGFloat = 0.0
        var Alpha: CGFloat = 0.0
        self.getHue(&Hue, saturation: &Saturation, brightness: &Brightness, alpha: &Alpha)
        let Multiplier = Percent
        Brightness = Brightness * Multiplier
        return UIColor(hue: Hue, saturation: Saturation, brightness: Brightness, alpha: Alpha)
    }
    
    /// Returns a more saturated version of the instance color.
    /// - Paraemter By: The percent value to multiply the instance color's saturation component by.
    ///                 If this is not a normal value (0.0 - 1.0), the original color is returned
    ///                 unchanged.
    /// - Returns: Increased saturation color.
    func Saturate(By Percent: CGFloat) -> UIColor
    {
        if Percent >= 1.0
        {
            return self
        }
        if Percent < 0.0
        {
            return self
        }
        var Hue: CGFloat = 0.0
        var Saturation: CGFloat = 0.0
        var Brightness: CGFloat = 0.0
        var Alpha: CGFloat = 0.0
        self.getHue(&Hue, saturation: &Saturation, brightness: &Brightness, alpha: &Alpha)
        let Multiplier = 1.0 + Percent
        Saturation = Saturation * Multiplier
        return UIColor(hue: Hue, saturation: Saturation, brightness: Brightness, alpha: Alpha)
    }
    
    /// Returns a desaturated version of the instance color.
    /// - Paraemter By: The percent value to multiply the instance color's saturation component by.
    ///                 If this is not a normal value (0.0 - 1.0), the original color is returned
    ///                 unchanged.
    /// - Returns: Desaturated color.
    func Desaturate(By Percent: CGFloat) -> UIColor
    {
        if Percent >= 1.0
        {
            return self
        }
        if Percent < 0.0
        {
            return self
        }
        var Hue: CGFloat = 0.0
        var Saturation: CGFloat = 0.0
        var Brightness: CGFloat = 0.0
        var Alpha: CGFloat = 0.0
        self.getHue(&Hue, saturation: &Saturation, brightness: &Brightness, alpha: &Alpha)
        let Multiplier = Percent
        Saturation = Saturation * Multiplier
        return UIColor(hue: Hue, saturation: Saturation, brightness: Brightness, alpha: Alpha)
    }
    
    static func DrawSwatch(Color: UIColor, InRect: CGRect) -> UIImage
    {
        let Result = UIImage(Color: Color, Size: CGSize(width: InRect.width, height: InRect.height))
        return Result
    }
    
    func DrawSwatch(_ InRect: CGRect) -> UIImage
    {
        return UIColor.DrawSwatch(Color: self, InRect: InRect)
    }
    
    /// Returns the normalized red value.
    var r: CGFloat
    {
        get
        {
            var Red: CGFloat = 0.0
            var Green: CGFloat = 0.0
            var Blue: CGFloat = 0.0
            var Alpha: CGFloat = 0.0
            self.getRed(&Red, green: &Green, blue: &Blue, alpha: &Alpha)
            return Red
        }
    }
    
    /// Returns the normalized green value.
    var g: CGFloat
    {
        get
        {
            var Red: CGFloat = 0.0
            var Green: CGFloat = 0.0
            var Blue: CGFloat = 0.0
            var Alpha: CGFloat = 0.0
            self.getRed(&Red, green: &Green, blue: &Blue, alpha: &Alpha)
            return Green
        }
    }
    
    /// Returns the normalized blue value.
    var b: CGFloat
    {
        get
        {
            var Red: CGFloat = 0.0
            var Green: CGFloat = 0.0
            var Blue: CGFloat = 0.0
            var Alpha: CGFloat = 0.0
            self.getRed(&Red, green: &Green, blue: &Blue, alpha: &Alpha)
            return Blue
        }
    }
    
    /// Returns the normalized alpha value.
    var a: CGFloat
    {
        get
        {
            var Red: CGFloat = 0.0
            var Green: CGFloat = 0.0
            var Blue: CGFloat = 0.0
            var Alpha: CGFloat = 0.0
            self.getRed(&Red, green: &Green, blue: &Blue, alpha: &Alpha)
            return Alpha
        }
    }
    
    static func Random(MinRed: CGFloat = 0.5, MinGreen: CGFloat = 0.5, MinBlue: CGFloat = 0.5) -> UIColor
    {
        let Red = CGFloat.random(in: MinRed ... 1.0)
        let Green = CGFloat.random(in: MinGreen ... 1.0)
        let Blue = CGFloat.random(in: MinBlue ... 1.0)
        return UIColor(red: Red, green: Green, blue: Blue, alpha: 1.0)
    }
    
    static func Random(MaxRed: CGFloat = 0.5, MaxGreen: CGFloat = 0.5, MaxBlue: CGFloat = 0.5) -> UIColor
    {
        let Red = CGFloat.random(in: 0.0 ... MaxRed)
        let Green = CGFloat.random(in: 0.0 ... MaxGreen)
        let Blue = CGFloat.random(in: 0.0 ... MaxBlue)
        return UIColor(red: Red, green: Green, blue: Blue, alpha: 1.0)
    }
    
    static func Random() -> UIColor
    {
        let Red = CGFloat.random(in: 0.0 ... 1.0)
        let Green = CGFloat.random(in: 0.0 ... 1.0)
        let Blue = CGFloat.random(in: 0.0 ... 1.0)
        return UIColor(red: Red, green: Green, blue: Blue, alpha: 1.0)
    }
    
    static func Random(RedLow: CGFloat = 0.2, RedHigh: CGFloat = 0.8, GreenLow: CGFloat = 0.2,
                       GreenHigh: CGFloat = 0.8, BlueLow: CGFloat = 0.2, BlueHigh: CGFloat = 0.8) -> UIColor
    {
        var ARedLow = RedLow
        var ARedHigh = RedHigh
        if ARedLow > ARedHigh
        {
            swap(&ARedLow, &ARedHigh)
        }
        var AGreenLow = GreenLow
        var AGreenHigh = GreenHigh
        if AGreenLow > AGreenHigh
        {
            swap(&AGreenLow, &AGreenHigh)
        }
        var ABlueLow = BlueLow
        var ABlueHigh = BlueHigh
        if ABlueLow > ABlueHigh
        {
            swap(&ABlueLow, &ABlueHigh)
        }
        let Red = CGFloat.random(in: ARedLow ... ARedHigh)
        let Green = CGFloat.random(in: AGreenLow ... AGreenHigh)
        let Blue = CGFloat.random(in: ABlueLow ... ABlueHigh)
        return UIColor(red: Red, green: Green, blue: Blue, alpha: 1.0)
    }
    
    /// Compare the instance color with the passed color using a common colorspace.
    /// - Notes:
    ///   - Both the instance color and the passed color are converted to the `sRGB`
    ///     colorspace.
    ///   - The alpha channel is part of the comparison.
    /// - Parameter Other: The other color to compare to the instance color.
    /// - Returns: True if the colors are the same in the common colorspace, false if not.
    func SameAs(_ Other: UIColor) -> Bool
    {
        #if true
        let SelfColor = UIColor.ForceRGB(self)
        let OtherColor = UIColor.ForceRGB(Other)
        if SelfColor.r == OtherColor.r &&
            SelfColor.g == OtherColor.g &&
            SelfColor.b == OtherColor.b &&
            SelfColor.a == OtherColor.a
        {
            return true
        }
        return false
        #else
        let SelfColor = self.usingColorSpace(.sRGB)
        let OtherColor = Other.usingColorSpace(.sRGB)
        if SelfColor == OtherColor
        {
            return true
        }
        return false
        #endif
    }
    
    // MARK: - Named colors.
    
    static var Maroon: UIColor
    {
        get
        {
            return UIColor(HexString: "#800000")!
        }
    }
    
    static var Gold: UIColor
    {
        get
        {
            return UIColor(HexString: "#ffd700")!
        }
    }
    
    static var DavysGray: UIColor
    {
        get
        {
            return UIColor(HexString: "#555555")!
        }
    }
    
    static var Jet: UIColor
    {
        get
        {
            return UIColor(HexString: "#343434")!
        }
    }
    
    static var GunMetal: UIColor
    {
        get
        {
            return UIColor(HexString: "#2a3439")!
        }
    }
    
    static var BlackGray: UIColor
    {
        get
        {
            return UIColor(HexString: "#2e3234")!
        }
    }
    
    static var BlackGrey: UIColor
    {
        get
        {
            return BlackGray
        }
    }
    
    static var LightSkyBlue: UIColor
    {
        get
        {
            return UIColor(HexString: "#87cefa")!
        }
    }
    
    static var PrussianBlue: UIColor
    {
        get
        {
            return UIColor(HexString: "#003171")!
        }
    }
    
    static var BerkeleyBlue: UIColor
    {
        get
        {
            return UIColor(HexString: "#003262")!
        }
    }
    
    static var Sapphire: UIColor
    {
        get
        {
            return UIColor(HexString: "#082567")!
        }
    }
    
    static var Independence: UIColor
    {
        get
        {
            return UIColor(HexString: "#4c516d")!
        }
    }
    
    static var DelftBlue: UIColor
    {
        get
        {
            return UIColor(HexString: "#1f305e")!
        }
    }
    
    /// Resene Space Cadet color.
    /// - Notes: See [Resene Space Cadet](https://www.resene.co.nz/swatches/preview.php?chart=Resene%20Multi-finish%20range%20%282016%29&brand=Resene&name=Space%20Cadet)
    static var SpaceCadet: UIColor
    {
        get
        {
            return UIColor(HexString: "#1e2952")!
        }
    }
    
    static var Pistachio: UIColor
    {
        get
        {
            return UIColor(HexString: "#93c572")!
        }
    }
    
    static var Lime: UIColor
    {
        get
        {
            return UIColor(HexString: "#bfff00")!
        }
    }
    
    static var Midori: UIColor
    {
        get
        {
            return UIColor(HexString: "#2a603b")!
        }
    }
    
    static var Botan: UIColor
    {
        get
        {
            return UIColor(HexString: "#a4345d")!
        }
    }
    
    static var Shironeri: UIColor
    {
        get
        {
            return UIColor(HexString: "#ffddca")!
        }
    }
    
    static var Ajiiro: UIColor
    {
        get
        {
            return UIColor(HexString: "#ebf6f7")!
        }
    }
    
    static var ArtichokeGreen: UIColor
    {
        get
        {
            return UIColor(HexString: "#4b6f44")!
        }
    }
    
    static var TeaGreen: UIColor
    {
        get
        {
            return UIColor(HexString: "#d0f0c0")!
        }
    }
    
    static var PacificBlue: UIColor
    {
        get
        {
            return UIColor(HexString: "#009dc4")!
        }
    }
    
    static var UltraPink: UIColor
    {
        get
        {
            return UIColor(HexString: "#ff6fff")!
        }
    }
    
    static var Sunglow: UIColor
    {
        get
        {
            return UIColor(HexString: "#ffcc33")!
        }
    }
    
    static var Scarlet: UIColor
    {
        get
        {
            return UIColor(HexString: "#ff2400")!
        }
    }
    
    static var AzukiIro: UIColor
    {
        get
        {
            return UIColor(HexString: "#672422")!
        }
    }
    
    static var TomorokoshiIro: UIColor
    {
        get
        {
            return UIColor(HexString: "#faa945")!
        }
    }
    
    static var Ebicha: UIColor
    {
        get
        {
            return UIColor(HexString: "#5e2824")!
        }
    }
    
    static var Ake: UIColor
    {
        get
        {
            return UIColor(HexString: "#cf3a24")!
        }
    }
    
    static var Suzumecha: UIColor
    {
        get
        {
            return UIColor(HexString: "#8c4736")!
        }
    }
    
    static var Momoshiocha: UIColor
    {
        get
        {
            return UIColor(HexString: "#542d24")!
        }
    }
    
    static var TobiIro: UIColor
    {
        get
        {
            return UIColor(HexString: "#4cc21b")!
        }
    }
    
    static var Kurotobi: UIColor
    {
        get
        {
            return UIColor(HexString: "#351e1c")!
        }
    }
    
    // MARK: - Color shifting
    
    /// Returns the number of seconds in a given time period.
    /// - Parameter Period: Length of a period whose number of seconds is returned.
    /// - Parameter In: The date used to determine the month to return the number of seconds.
    /// - Returns: Number of seconds in the specified time period.
    func SecondsIn(Period: ColorTimePeriods, In: Date) -> Int
    {
        switch Period
        {
            case .Minutes:
                return 60
                
            case .Hours:
                return 60 * 60
                
            case .Days:
                return 60 * 60 * 24
                
            case .Months:
                let Cal = Calendar.current
                let Interval = Cal.dateInterval(of: .month, for: In)
                let Days = Cal.dateComponents([.day], from: Interval!.start, to: Interval!.end).day!
                return Days * 60 * 60 * 24
        }
    }
    
    /// Given the current time, return the number of seconds in a given period of time that have elapsed.
    /// - Parameter OfPeriod: The color cycle period length.
    /// - From: The current time used to determine how many seconds have elapsed.
    /// - Returns: Number of seconds away from the integral start of the specified period of time.
    func SecondsFromStart(OfPeriod: ColorTimePeriods, From: Date) -> Int
    {
        let Cal = Calendar.current
        switch OfPeriod
        {
            case .Minutes:
                let Seconds = Cal.component(.second, from: From)
                return Seconds
                
            case .Hours:
                let Seconds = Cal.component(.second, from: From)
                let Minutes = Cal.component(.minute, from: From)
                return (Minutes * 60) + Seconds
                
            case .Days:
                let Seconds = Cal.component(.second, from: From)
                let Minutes = Cal.component(.minute, from: From)
                let Hours = Cal.component(.hour, from: From)
                return (Hours * 60 * 60) + (Minutes * 60) + Seconds
                
            case .Months:
                let Seconds = Cal.component(.second, from: From)
                let Minutes = Cal.component(.minute, from: From)
                let Hours = Cal.component(.hour, from: From)
                let Days = Cal.component(.day, from: From)
                return ((Days - 1) * 24 * 60 * 60) + (Hours * 60 * 60) + (Minutes * 60) + Seconds
        }
    }
    
    /// Returns the current percent of the way through the specified time period.
    ///
    /// - Parameters:
    ///   - Period: Determines the period.
    ///   - Now: Current time the percent is desired for.
    /// - Returns: Percent of the way through the period.
    func Percent(Period: ColorTimePeriods, Now: Date) -> Double
    {
        let TotalTime = SecondsIn(Period: Period, In: Now)
        let FromStart = SecondsFromStart(OfPeriod: Period, From: Now)
        let TimePercent = Double(FromStart) / Double(TotalTime)
        return TimePercent
    }
    
    /// Move the instance color to a new color.
    /// - Warning: This function will crash on grayscale colors. The caller should call `InRGB` before calling
    ///         this function.
    /// - Parameter To: The current time over the reference length of time - determines the new color.
    /// - Parameter Period: The length of the color cycle period.
    /// - Parameter Forward: Determines the direction of the motion of the color.
    /// - Returns: Updated color.
    func Move(To: Date, Period: ColorTimePeriods, Forward: Bool, FinalHue: inout CGFloat) -> UIColor
    {
        let (Hue, Sat, Bri) = HSB
        let PeriodPercent = Percent(Period: Period, Now: To)
        var WorkingHue = (Hue * 360.0) + CGFloat(PeriodPercent * 360.0)
        WorkingHue = fmod(WorkingHue, 360.0)
        WorkingHue = WorkingHue / 360.0
        if !Forward
        {
            WorkingHue = 1.0 - WorkingHue
        }
        FinalHue = WorkingHue
        let Final = UIColor(hue: WorkingHue, saturation: Sat, brightness: Bri, alpha: 1.0)
        return Final
    }
    
    /// Blend two colors together.
    /// - Parameter Color1: First color.
    /// - Parameter Color2: Second color.
    /// - Parameter IncludeAlpha: If true, alpha is blended as well. If false, `1.0` is used for alpha.
    /// - Parameter Percent: Spatial distance expressed as a normal for how far apart the point is between
    ///                      the two colors.
    /// - Returns: Blended color.
    public static func BlendColors(Color1: UIColor, Color2: UIColor, IncludeAlpha: Bool = false,
                                   Percent: CGFloat) -> UIColor
    {
        let R1 = Color1.r
        let R2 = Color2.r
        let G1 = Color1.g
        let G2 = Color2.g
        let B1 = Color1.b
        let B2 = Color2.b
        let A1 = Color1.a
        let A2 = Color2.a
        
        let RSum = (R1 * (1.0 - Percent)) + (R2 * Percent)
        let GSum = (G1 * (1.0 - Percent)) + (G2 * Percent)
        let BSum = (B1 * (1.0 - Percent)) + (B2 * Percent)
        var ASum: CGFloat = 0.0
        if IncludeAlpha
        {
            ASum = (A1 * (1.0 - Percent)) + (A2 * Percent)
        }
        else
        {
            ASum = 1.09
        }
        
        return UIColor(red: RSum, green: GSum, blue: BSum, alpha: ASum)
    }
    
    /// Returns the opposite color of the instance color, where "opposite" is defined in terms of hue (technically,
    /// "opposite" means 180° away form the original color. Additionally, saturation is "inverted".
    /// - Returns: High-constrast color based on the instance color.
    public func OppositeColor() -> UIColor
    {
        let (H, S, B) = self.HSB
        var NewHue = 360.0 * H
        NewHue = NewHue + 180.0
        NewHue = fmod(NewHue, 360.0) / 360.0
        var NewSat = 100.0 * S
        NewSat = NewSat + 50.0
        NewSat = fmod(NewSat, 100.0) / 100.0
        let Final = UIColor(hue: NewHue, saturation: NewSat, brightness: B, alpha: 1.0)
        return Final
    }
}

enum ColorTimePeriods
{
    case Minutes
    case Hours
    case Days
    case Months
}

